import { Component, OnInit, ViewChild, Output, EventEmitter } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { UserService } from '../../user.service';
import { MenuItem } from 'primeng/api';
import { Injectable } from '@angular/core';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { environment } from '../../../environments/environment';
import { ElementRef } from '@angular/core';

import { SelectItem } from 'primeng/components/common/api';
import { Message } from 'primeng/components/common/api';
import { ToggleButtonModule } from 'primeng/togglebutton';
import { LoadingService } from '../../loading.service';
import { DisplaySettingsService } from '../../display-settings.service';
import { TooltipModule } from 'primeng/tooltip';



import '../../../../lib/d3.js';

import * as jQuery from 'jquery';
import '../../../../lib/biocircos.js';

import '../../../../lib/bam.iobio2.js';

import { CheckboxModule } from 'primeng/checkbox';
import { FileNode } from '../project-panel/project-panel.component';
import { DataBinner } from '../../../../routes/binner';

declare let BioCircos: any;


export class CircosGroup {
  selectedChromosome: Chromosome;
  chromosomeSelected: boolean;
  chromosomes: Chromosome[];
  isChecked: boolean;
  isGenomeViewLoaded: boolean;
  items: FileNode[];
  name: string;
  range: number[];
  reverse: boolean;
  isReversed: boolean;
  end: number;
  start: number;
  loaded: boolean;
  binned: boolean = true;
}

export class DataTrack {
  format: string;
  data: Array<any>;
}

// Chromosome object for the zoom
export class Chromosome {
  id: any;
  length: any;
  start: any;
  end: any;
}

@Component({
  selector: 'app-biocircos',
  templateUrl: './biocircos.component.html',
  styleUrls: ['./biocircos.component.css'],
  providers: []
})
export class BiocircosComponent implements OnInit {
  // Messages
  msgs: Message[] = [];
  msg = 'Create a new project or select an existing one';
  insert_fasta_msgs: Message[] = [];
  create_project_msgs: Message[] = [];

  filesNames: any;


  @ViewChild('biocircos') biocircos;


  chromosomes: Chromosome[] = [];
  selectedChromosome: Chromosome = null;
  selectedReorderedChromosome: Chromosome = null;
  genomeData: any = null;
  fullImagePath: string;
  BioCircos01 = null;
  circosDisplayed = false;

  tracksArray: string[] = []; // array generated by re-ordering carried by the user

  maxRadiusTrack1 = 400;
  space = 10;
  minRadiusTrack1 = this.maxRadiusTrack1 - this.space;
  lastRadius = this.minRadiusTrack1;
  trackSize = 30;

  highlightedRegionAnnotation = 'genes';

  legendBooleans: any;
  tickLength: number;
  totalGenomeSize: number;

  // Retrieve the slider from the html
  anPosition: any = {};
  dataDisplayed = null;

  DisplayMessages = true;
  showHomoSNP = false;
  selectionPos = { start: null, end: null, groupStart: null, groupEnd: null };
  graphTypeSelected = 'histogram';

  linksDisplayed: any;
  linksBoolean: boolean = false;

  @ViewChild('circosControls') circosControls;

  showLinksLegend(show: boolean){
    this.circosControls.showLinksLegend = show;
  }

  @Output() onGroupListAdded = new EventEmitter<string[]>();
  @Output() modeChanged = new EventEmitter<string>();

  @Output()
  onCircosClick = new EventEmitter<number[]>();

  @Output()
  openCustomisation = new EventEmitter<any>();

  TEXT01 = null;

  mode: string;

  constructor(private userService: UserService, private http: HttpClient,
    private el: ElementRef, public loadingService: LoadingService, private displaySettingsService: DisplaySettingsService) {
  }


  rescaleValue(data): any[] {
    const newData = [];
    for (let i = 0; i < data.length; i++) {
      newData.push({ chr: data[i].chr, pos: data[i].pos, value: 1 / (1 + Math.exp(-data[i].value)) });
    }
    return newData;
  }

  catchGraphTypeSelection(event) {
    let data;
    let mode;
    this.graphTypeSelected = event;
    data = this.dataDisplayed;
    mode = this.mode;
    this.submitDisplayCircos(data, mode);
  }

  heatmapToARC(data, format) {
    const newData = [];
    const startCol = [255, 0, 0];
    const endCol = [0, 205, 0];
    let color;

    for (let i = 0; i < data.length; i++) {
      if (format === 'de' || format === 'diffExp') {
        if (data[i].value === 0) {
          color = '#ffff00';
        } else {
          color = this.colorGradient(1 / (1 + Math.exp(-data[i].value)), startCol, endCol);
          color = this.rgb(color[0], color[1], color[2]);
        }
        newData.push({
          chr: data[i].chr, start: data[i].start - this.circosControls.zoomStart,
          end: data[i].end - this.circosControls.zoomStart, startTooltip: data[i].start,
          endTooltip: data[i].end, color: color, des: data[i].name, logFC: data[i].value
        });
      } else {
        newData.push({
          chr: data[i].chr, start: data[i].start - this.circosControls.zoomStart,
          end: data[i].end - this.circosControls.zoomStart, startTooltip: data[i].start,
          endTooltip: data[i].end, color: 'blue', des: data[i].des, logFC: ''
        });
      }
    }
    return newData;
  }

  addBinValueToolTip(data, fasta, genomeLength): void {
    const bin = this.toMb(genomeLength);

    if (this.circosControls.selectedGroups.length % 2 === 0) {

      let nbBeforeReverse = this.circosControls.selectedGroups.length / 2;

      let lastGrp;
      if (data[0].chr.split('_')) {
        lastGrp = data[0].chr.split('_')[0];
      } else { return; }
      let newGrp = lastGrp;
      let chrZoomed;
      for (let i = 0; i < data.length; i++) {
        if (data[i].chr === this.circosControls.chromosomeZoomed) {
          chrZoomed = 1;
        } else {
          chrZoomed = 0;
        }
        if (nbBeforeReverse > 0) {
          if (data[i].pos) {
            data[i].posTooltip = data[i].pos;
            data[i].pos = data[i].pos - chrZoomed * this.circosControls.zoomStart;
          } else {
            data[i].startTooltip = data[i].start + chrZoomed * this.circosControls.zoomStart;
            data[i].endTooltip = data[i].end + chrZoomed * this.circosControls.zoomStart;
            data[i].name = bin + 'Kb';
          }
        } else {

          let chrSize = fasta.find(el => el[0] === data[i].chr);
          chrSize = chrSize[1];

          if (data[i].pos) {
            data[i].posTooltip = parseInt(chrSize) - data[i].pos;
            data[i].pos = data[i].pos - chrZoomed * this.circosControls.zoomStart;
          } else {
            data[i].startTooltip = parseInt(chrSize) - (data[i].start + chrZoomed * this.circosControls.zoomStart);
            data[i].endTooltip = parseInt(chrSize) - (data[i].end + chrZoomed * this.circosControls.zoomStart);
            data[i].name = bin + 'Kb';

          }
        }
        newGrp = data[i].chr.split('_')[0];

        if (lastGrp != newGrp) {
          lastGrp = newGrp;
          nbBeforeReverse--;
        }
      }
    } else {
      for (let i = 0; i < data.length; i++) {
        if (data[i].pos) {
          data[i].posTooltip = data[i].pos;
          data[i].pos = data[i].pos - this.circosControls.zoomStart;
        } else {
          data[i].startTooltip = data[i].start + this.circosControls.zoomStart;
          data[i].endTooltip = data[i].end + this.circosControls.zoomStart;
          data[i].name = bin + 'Kb';
        }
      }
    }
    return data;
  }
  toMb(number): number {
    number = Math.floor(number / (1000 * 1000));
    return number;
  }

  ngOnInit() {

    this.biocircos.nativeElement.oncontextmenu = function () {
      return false;
    };


    this.TEXT01 = ['TEXT01', {
      x: 0,
      y: 0,
      textSize: 16,
      textColor: 'black',
      textOpacity: 0.8,
      text: ''
    }];
    this.fullImagePath = '/vcfLegend.png';
    this.legendBooleans = {
      fastaChrBoolean: false,
      annotChrBoolean: false,
      diffChrBoolean: false,
      genomCovBoolean: false,
      vcfChrBoolean: false,
      transcriptomicCov: false,
      expressionBoolean: false,
      snpLinkBoolean: false,
    };
    this.create_msgs(['Please Sign In', 'Enter Fasta']);
  }

  clear_messages() {
    this.msgs = [];
  }



  create_msgs(messages) {
    if (this.DisplayMessages === true) {
      this.msgs = [];
      for (let i = 0; i < messages.length; i++) {
        if (messages[i] === 'warning') {
          //this.msgs.push({ severity: 'warn', summary: 'Warn Message',
          //detail: 'Be sure to select the correct fasta file before you upload any other file type!' });
        } else {
          //this.msgs.push({ severity: 'info', summary: 'Info Message', detail: messages[i] });
        }
      }
    }
  }

  ngAfterViewInit() {
    this.RegisterMouseDown();
    this.RegisterMouseUp();
  }

  RegisterMouseDown() {
    this.el.nativeElement.removeEventListener('mousedown', this.OnMouseDown.bind(this));
    this.el.nativeElement.addEventListener('mousedown', this.OnMouseDown.bind(this));
  }
  RegisterMouseUp() {
    this.el.nativeElement.removeEventListener('HTMLEvents', this.OnMouseUp.bind(this));
    this.el.nativeElement.addEventListener('HTMLEvents', this.OnMouseUp.bind(this));
  }
  OnMouseUp(event: any) {
    if (event.target.attributes.class) {
      if (event.target.attributes.class.nodeValue === "BioCircosZOOM_SLIDER") {
        this.selectionPos.end = this.BioCircos01.settings.zoom_end; // add values to object
        this.selectionPos.groupEnd = this.BioCircos01.settings.groupEnd; // event.target.attributes.group.nodeValue;

        // only if start and end are in the same group and chromosome
        const clickedChrGroup = this.selectionPos.groupStart.split("_", 2); // get the group name
        // from the property in clicked svg tag and split at which divides group name and chromosome number
        let clickedGroupName = clickedChrGroup[0];
        let clickedChr;
        if (!clickedChrGroup[1]) {
          // only a chomosome number set, no groups so emit to project panel
          clickedChr = clickedGroupName;
          clickedGroupName = "Group 1";
        } else {
          clickedChr = clickedChrGroup[1];
        }

        let clickedGroupId = this.circosControls.groups
          .map(function(e) {
            return e.name;
          })
          .indexOf(clickedGroupName); //find the id of the group name in the groups array in circos-controls
        let clickedGroupObj = this.circosControls.groups[clickedGroupId]; //get it as an object too
        let chrId = clickedGroupObj.chromosomes
          .map(function(e) {
            return e.id;
          })
          .indexOf(clickedChr); // get the id of the chromosome that matches the clicked chromosome number
        clickedGroupObj.selectedChromosome = clickedGroupObj.chromosomes[chrId]; // set up the chromosome object
        clickedGroupObj.chromosomeSelected = true;

        clickedGroupObj.range[0] = Math.min(
          this.selectionPos.start,
          this.selectionPos.end
        ); // add positions to range array in object
        clickedGroupObj.range[1] = Math.max(
          this.selectionPos.start,
          this.selectionPos.end
        );
        clickedGroupObj.range = JSON.parse(
          JSON.stringify(clickedGroupObj.range)
        );

        this.circosControls.zoomIn(clickedGroupId, clickedGroupObj);
      }
    }
  }


  currentZoomChromosome: Chromosome;

  OnMouseDown(event: any) {
    if (event.target.attributes.class) {
      if (event.target.attributes.class.nodeValue === "BioCircosZOOM_SLIDER") {
        //console.log('heatmap order: ' + event.target.attributes.order.nodeValue); //to differentiate between heatmap tracks, 0 is outermost, highest number most innermost
        this.selectionPos.start = this.BioCircos01.settings.zoom_start; // set start position and group
        this.selectionPos.groupStart = this.BioCircos01.settings.groupStart; // event.target.attributes.group.nodeValue;
      }
      if (event.target.attributes.class.nodeValue === "BioCircosHEATMAP") {
        //  FOR LINEAR
        if (this.circosControls.selectedGroups.length === 1) {
          this.selectionPos.groupStart =
            event.target.attributes.group.nodeValue;
          let clickedChrGroup = this.selectionPos.groupStart.split("_", 2); //get the group name from the property in clicked svg tag and split at _ which divides group name and chromosome number
          let clickedGroupName = clickedChrGroup[0];
          let clickedChr;
          if (!clickedChrGroup[1]) {
            // only a chomosome number set, no groups so emit to project panel
            clickedChr = clickedGroupName;
            clickedGroupName = "Group 1";
          } else {
            clickedChr = clickedChrGroup[1];
          }
          this.anPosition = {};
          this.anPosition.start = Math.round(
            event.target.__data__.heatmap_startTooltip
          );
          this.anPosition.end = Math.round(
            event.target.__data__.heatmap_endTooltip
          );

          this.anPosition.chr = {
            id: clickedChr,
            size: this.dataDisplayed.fasta.data.find(el => el[0] === this.selectionPos.groupStart)[1]
          };
          this.anPosition.files = { annotation: [], vcf: [] };
          for (const file of this.dataDisplayed.tracks) {
            if (file.format === "vcf") {
              this.anPosition.files.vcf.push({
                id: file.file,
                name: this.filesNames[file.file]
              });
            } else if (file.format === "annotation") {
              this.anPosition.files.annotation.push({
                id: file.file,
                name: this.filesNames[file.file]
              });
            }
          }
          this.onCircosClick.emit(this.anPosition);
        }
      }
      if (event.target.attributes.class.nodeValue.includes("BioCircosGENOME")) {
        // if the fasta track was clicked
        //let clickedChrGroup = event.target.attributes.group.nodeValue.split("_",2); //get the group name from the property in clicked chromosome svg tag and split at _ which divides group name and chromosome number
        let clickedChrGroup = this.BioCircos01.argumentsBiocircosGenome[event.target.__data__.index][0].split("_")
        let clickedGroupName = clickedChrGroup[0];
        let clickedChr;
        if (!clickedChrGroup[1]) {
          // only a chomosome number set, no groups so emit to project panel
          clickedChr = clickedGroupName;
          clickedGroupName = "Group 1";
        } else {
          clickedChr = clickedChrGroup[1];
        }
        const clickedGroupId = this.circosControls.groups
          .map(function(e) {
            return e.name;
          })
          .indexOf(clickedGroupName); // find the id of the group name in the groups array in circos-controls
        const clickedGroupObj = this.circosControls.groups[clickedGroupId]; // get it as an object too
        let chrId = clickedGroupObj.chromosomes
          .map(function(e) {
            return e.id;
          })
          .indexOf(clickedChr); //get the id of the chromosome that matches the clicked chromosome number
        clickedGroupObj.selectedChromosome = clickedGroupObj.chromosomes[chrId]; //set up the chromosome object
        clickedGroupObj.chromosomeSelected = true;

        this.circosControls.selectChromosome(clickedGroupId, clickedGroupObj);
      }
    }
  }


  clear() { // Removes the biocircos svg from the HTML if it is existing
    if (this.biocircos.nativeElement.childNodes.length > 0) {
      this.biocircos.nativeElement.removeChild(this.biocircos.nativeElement.childNodes[0]);


      let tooltips = document.getElementsByClassName('BioCircosLINKTooltip'); // remove the link tooltips
      while (tooltips[0]) {
        tooltips[0].parentNode.removeChild(tooltips[0]);
      }
      tooltips = document.getElementsByClassName('BioCircosHISTOGRAMTooltip'); // remove the link tooltips
      while (tooltips[0]) {
        tooltips[0].parentNode.removeChild(tooltips[0]);
      }
      tooltips = document.getElementsByClassName('BioCircosHeatmapTooltip'); // remove the link tooltips
      while (tooltips[0]) {
        tooltips[0].parentNode.removeChild(tooltips[0]);
      }
    }
    this.legendBooleans.fastaChrBoolean = false;
    this.legendBooleans.annotChrBoolean = false;
    this.legendBooleans.diffChrBoolean = false;
    this.legendBooleans.genomCovBoolean = false;
    this.legendBooleans.vcfChrBoolean = false;
    this.legendBooleans.transcriptomicCov = false;
    this.legendBooleans.expressionBoolean = false;
    this.legendBooleans.snpLinkBoolean = false;
    this.dataDisplayed = null;
  }

  clearProject() {
    this.clear();
    this.circosControls.clear();
  }

  updateGroups(data) { // investigate: where is this used?
    this.onGroupListAdded.emit(data);
  }



  createZOOM_SLIDER(fasta, genomeLength): any {
    const regionSize = genomeLength / 100;
    const zoom_slider = [];

    for (let j = 0; j < fasta.length; j++) {
      for (let k = 0; k < fasta[j][1] / regionSize; k++) {
        if (Math.floor((k + 1) * regionSize) < fasta[j][1]) {
          zoom_slider.push({
            chr: fasta[j][0], start: Math.floor(k * regionSize), end: Math.floor((k + 1) * regionSize),
            actualStart: Math.floor(k * regionSize) + this.circosControls.zoomStart,
            actualEnd: Math.floor((k + 1) * regionSize) + this.circosControls.zoomStart
          });
        } else {
          zoom_slider.push({
            chr: fasta[j][0], start: Math.floor(k * regionSize), end: fasta[j][1],
            actualStart: Math.floor(k * regionSize) + this.circosControls.zoomStart,
            actualEnd: fasta[j][1] + this.circosControls.zoomStart
          });
        }
      }
    }

    return zoom_slider;
  }

  submitFileList(data) {
    this.circosControls.setFileList(data);
  }

  submitDisplayCircos(data, mode): void {

    this.clear();

    if (mode === 'comparison') {
      this.mode = 'comparison';
      this.displaySettingsService.mode = 'comparison';
      this.modeChanged.emit('comparison');

    } else {
      this.modeChanged.emit('single');
      this.mode = 'single';
      this.displaySettingsService.mode = 'single';
    }

    this.loadingService.isCharging = true;

    this.dataDisplayed = data;

    this.genomeData = data;

    const tracksArray: string[] = [];

    let genomeLength = 0;
    for (let i = 0; i < data.fasta.data.length; i++) {
      genomeLength += data.fasta.data[i][1];
      this.totalGenomeSize = genomeLength;
    }

    if (data) {

      if (data.tracks.length === 0 && !this.linksDisplayed) {
        this.circosDisplayed = false;
        this.msg = 'Upload some files or select files from the list to display the circos';
      } else {
        this.circosDisplayed = true;

        for (let i = 0; i < data.fasta.data.length; i++) {
          if (data.fasta) {
            tracksArray.push('fasta');
            this.legendBooleans.fastaChrBoolean = true;
          }
        }

        let nbTracks = data.tracks.length + 3;

        if (data.SNPLinks) {
          nbTracks++;
        }

        let annotationOrdiff = '';

        this.maxRadiusTrack1 = Math.min((this.biocircos.nativeElement.clientWidth * 0.85 - 20) / 2,
          (this.biocircos.nativeElement.clientHeight - 60) / 2);
        this.trackSize = Math.round(this.maxRadiusTrack1 / nbTracks);
        this.space = Math.ceil(((40 - nbTracks * 3) / 100) * this.trackSize);
        this.minRadiusTrack1 = this.maxRadiusTrack1 - this.trackSize / 2;
        this.lastRadius = this.minRadiusTrack1 - this.space;

        const modules = [];

        let rest = 0;
        let roundZoomStart = 0;
        this.defineTicks(genomeLength);
        let displayTickText = true;
        if (this.circosControls.selectedGroups.length > 1) {
          displayTickText = false;
        }

        this.tracksArray = tracksArray;
        let track;
        if (data.fasta.data.length === this.circosControls.selectedGroups.length) {
          const zoom_slider = this.createZOOM_SLIDER(data.fasta.data, genomeLength);

          modules.push(['ZOOM_SLIDER01', {
            minRadius: this.minRadiusTrack1,
            maxRadius: this.maxRadiusTrack1,
          }, zoom_slider]);

          if (this.circosControls.zoomStart != 0) {
            rest = this.tickLength - (this.circosControls.zoomStart % this.tickLength);
            roundZoomStart = Math.round(this.circosControls.zoomStart +
              (this.tickLength - (this.circosControls.zoomStart % this.tickLength)));
          }
        }

        this.lastRadius = this.minRadiusTrack1 - this.space;
        for (let i = 0; i < data.tracks.length; i++) { // Go through the whole array element by element and check the nature of the element
          track = data.tracks[i];

          if (track.format === 'vcf') { // if the file is a VCF file

            let vcfData = JSON.parse(JSON.stringify(track.data));

            tracksArray.push('vcf');
            this.legendBooleans.vcfChrBoolean = true;

            if (vcfData[0].pos === undefined) {
              // here add the if for checking emission
              if (this.graphTypeSelected === 'lineGraph') {
                vcfData = this.addBinValueToolTip(vcfData, data.fasta.data, genomeLength);
                for (let z = 0; z < vcfData.length; z++) {
                  vcfData[z].pos = (vcfData[z].start + vcfData[z].end) / 2;
                }
              } else {
                vcfData = this.addBinValueToolTip(vcfData, data.fasta.data, genomeLength);
              }

              if (this.graphTypeSelected === 'lineGraph') {
                modules.push(['LINE01', {
                  minRadius: this.lastRadius - this.trackSize,
                  maxRadius: this.lastRadius,
                  LineColor: '#FF6666',
                  LineWidth: 1
                }, vcfData, undefined]);
              } else {
                modules.push(['HISTOGRAM01', {
                  minRadius: this.lastRadius - this.trackSize,
                  maxRadius: this.lastRadius,
                  histogramFillColor: '#FF6666',

                }, vcfData]);
              }
              if (this.showHomoSNP) {

                let max = 0;
                for (let j = 0; j < vcfData.length; j++) {
                  if (vcfData[j].value > max) {
                    max = vcfData[j].value;
                  }
                }

                let vcfData2 = JSON.parse(JSON.stringify(track.data));

                for (let j = 0; j < vcfData2.length; j++) {
                  vcfData2[j].value = vcfData2[j].homo;
                }
                vcfData2 = this.addBinValueToolTip(vcfData2, data.fasta.data, genomeLength);

                if (this.graphTypeSelected === 'lineGraph') {
                  for (let z = 0; z < vcfData2.length; z++) {
                    vcfData2[z].pos = (vcfData2[z].start + vcfData2[z].end) / 2;
                  }

                  modules.push(['LINE01', {
                    minRadius: this.lastRadius - this.trackSize,
                    maxRadius: this.lastRadius,
                    LineColor: 'green',
                    LineWidth: 1
                  }, vcfData2, max]);
                } else {
                  modules.push(['HISTOGRAM01', {
                    minRadius: this.lastRadius - this.trackSize,
                    maxRadius: this.lastRadius,
                    histogramFillColor: 'green',

                  }, vcfData2, max]);
                }


              }


            } else {
              vcfData = this.addBinValueToolTip(vcfData, data.fasta.data, genomeLength);

              if (!vcfData[0].color) {
                let color;
                for (let j = 0; j < vcfData.length; j++) {
                  color = this.colorGradient(vcfData[j].homo, [255, 0, 0], [0, 255, 0]);
                  vcfData[j].color = this.rgb(color[0], color[1], color[2]);
                }

              }


              modules.push(['SNP01', {
                minRadius: this.lastRadius - this.trackSize + this.space / 2,
                maxRadius: this.lastRadius - this.space / 2,
                SNPFillColor: '#9400D3',
                PointType: 'circle',
                circleSize: 2,
                rectWidth: 2,
                rectHeight: 2
              }, vcfData]);
            }

            modules.push(['BACKGROUND01', {
              BginnerRadius: this.lastRadius - this.trackSize,
              BgouterRadius: this.lastRadius,
              BgFillColor: '#F2F2F2',
              BgborderColor: '#000',
              BgborderSize: 0.3,
              axisShow: 'true',
              axisWidth: 0.1,
              axisColor: '#000',
              axisNum: 8

            }]);

            this.lastRadius = this.lastRadius - this.trackSize - this.space;

          } else if (track.format === 'annotation') {
            let annot = JSON.parse(JSON.stringify(track.data));
            for (let j = 0; j < annot.length; j++) {
              //console.log(annot[j])
              annot[j].value = annot[j][this.highlightedRegionAnnotation];
              if (annot[j].value == null || annot[j].value === undefined) {
                annot[j].value = 0;
              }
            }

            tracksArray.push('annotation');
            this.legendBooleans.annotChrBoolean = true;
            if (track.isARC) {

              annot = this.heatmapToARC(annot, track.format);
              modules.push(['ARC01', {
                innerRadius: this.lastRadius - this.maxRadiusTrack1,
                outerRadius: this.lastRadius - this.maxRadiusTrack1,
              }, annot]);
              modules.push(['BACKGROUND01', {
                BginnerRadius: this.lastRadius - this.trackSize / 2,
                BgouterRadius: this.lastRadius,
                BgFillColor: 'orange',
                BgborderColor: '#000',
                BgborderSize: 0

              }]);
              annotationOrdiff = '<br>';

            } else {
              annot = this.addBinValueToolTip(annot, data.fasta.data, genomeLength);
              modules.push(['HEATMAP01', {
                innerRadius: this.lastRadius - this.maxRadiusTrack1,
                outerRadius: this.lastRadius - this.maxRadiusTrack1,
                maxColor: 'blue',
                minColor: 'orange'
              }, annot]);
            }
            this.lastRadius = this.lastRadius - (this.trackSize / 2) - this.space;
          } else if (track.format === 'diffExp' || track.format === 'de') {

            tracksArray.push('diffExp');
            this.legendBooleans.diffChrBoolean = true;
            let diffTrack = JSON.parse(JSON.stringify(track.data));

            diffTrack = this.heatmapToARC(diffTrack, track.format);
            modules.push(['ARC01', {
              innerRadius: this.lastRadius - this.maxRadiusTrack1,
              outerRadius: this.lastRadius - this.maxRadiusTrack1,
            }, diffTrack]);
            annotationOrdiff = '<br> logFC: ';
            modules.push(['BACKGROUND01', {
              BginnerRadius: this.lastRadius - this.trackSize / 2,
              BgouterRadius: this.lastRadius,
              BgFillColor: '#ffff00',
              BgborderColor: '#000',
              BgborderSize: 0

            }]);

            this.lastRadius = this.lastRadius - this.trackSize / 2 - this.space;
          } else if (track.format === 'transcriptomicCov' || track.format === 'bedcov') {

            tracksArray.push('transcriptomicCov');
            this.legendBooleans.transcriptomicCov = true;

            for (let j = 0; j < track.data.length; j++) {
              delete track.data[j]._id;
            }

            modules.push(['LINE01', {
              minRadius: this.lastRadius - this.trackSize + this.space / 2,
              maxRadius: this.lastRadius - this.space / 2,
              LineColor: '#307E80',
              LineWidth: 1
            }
              , this.rescaleValue(track.data)]);

            modules.push(['BACKGROUND01', {
              BginnerRadius: this.lastRadius - this.trackSize,
              BgouterRadius: this.lastRadius,
              BgFillColor: '#F2F2F2',
              BgborderColor: '#000',
              BgborderSize: 0.3
            }]);

            this.lastRadius = this.lastRadius - this.trackSize - this.space;
          } else if (track.format === 'genomicCov' || track.format === 'bam' || track.format === 'bai') {
            // track.data = this.rescaleValue(track.data)
            tracksArray.push('genomicCov');
            this.legendBooleans.genomCovBoolean = true;



            modules.push(['LINE02', {
              minRadius: this.lastRadius - this.trackSize,
              maxRadius: this.lastRadius,
              LineColor: '#ABCF27',
              LineWidth: 1
            }
              , track.data]);

            modules.push(['BACKGROUND02', {
              BginnerRadius: this.lastRadius - this.trackSize,
              BgouterRadius: this.lastRadius,
              BgFillColor: '#F2F2F2',
              BgborderColor: '#000',
              BgborderSize: 0.3
            }]);

            this.lastRadius = this.lastRadius - this.trackSize - this.space;
          } else if (track.format === 'expression' || track.format === 'results') {
            tracksArray.push('expression');
            this.legendBooleans.expressionBoolean = true;

            /*  for (let j = 0; j < track.data.length; j++) {
                delete track.data[j]._id;
              }*/

            modules.push(['LINE03', {
              minRadius: this.lastRadius - this.trackSize + this.space / 2,
              maxRadius: this.lastRadius - this.space / 2,
              LineColor: '#723584',
              LineWidth: 1
            }
              , this.rescaleValue(track.data)]);

            modules.push(['BACKGROUND03', {
              BginnerRadius: this.lastRadius - this.trackSize,
              BgouterRadius: this.lastRadius,
              BgFillColor: '#F2F2F2',
              BgborderColor: '#000',
              BgborderSize: 0.3
            }]);

            this.lastRadius = this.lastRadius - this.trackSize - this.space;
          } else if (track.format === "InDelSNP") {
            let annot = JSON.parse(JSON.stringify(track.data));
            for (let j = 0; j < annot.length; j++) {
              annot[j].value = annot[j][this.highlightedRegionAnnotation];
              if (annot[j].value == null || annot[j].value === undefined) {
                annot[j].value = 0;
              }
            }

            tracksArray.push('InDelSNP');
            this.legendBooleans.annotChrBoolean = true;
              //annot = this.heatmapToARC(annot, track.format);
              modules.push(['ARC01', {
                innerRadius: this.lastRadius - this.maxRadiusTrack1,
                outerRadius: this.lastRadius - this.maxRadiusTrack1,
              }, annot]);
              modules.push(['BACKGROUND01', {
                BginnerRadius: this.lastRadius - this.trackSize / 2,
                BgouterRadius: this.lastRadius,
                BgFillColor: '#b0c4de',
                BgborderColor: '#000',
                BgborderSize: 0

              }]);
              annotationOrdiff = '<br>';
              this.lastRadius = this.lastRadius - this.trackSize - this.space;
          }
        }



        for (let p = 0; p < data.tracks.length; p++) {
          //in case of single group, links contains no data, maybe change later
          if (data.tracks[p].format === "rearrangment" && data.tracks[p].data) {

            //set the width of links to correctly represent the fragment length
            //let totalLength = data.fasta.data.reduce((x, y) => x + y[1],0)
            //for (let k=0; k<data.tracks[p].data.length; k++) {
            //  data.tracks[p].data[k].width=Math.trunc(2*Math.PI*(data.tracks[p].data[k].g1end-data.tracks[p].data[k].g1start)/totalLength*this.lastRadius)
            //}
            
            modules.push(['LINK01', {
              LINKMouseEvent: true,
              LinkRadius: this.lastRadius,
              LinkFillColor: '#F26223',
              displayLinkAxis: false,
              LinkAxisColor: '#B8B8B8',
              LinkAxisWidth: 0.5,
              LinkAxisPad: 3,
              displayLinkLabel: false,
              LINKMouseOverDisplay: true,
              LINKMouseOverOpacity: 1,
            }, this.filterLinks(data.tracks[p].data)]);

            this.lastRadius = this.lastRadius - this.trackSize - this.space;
            //only one links file is permitted
            break;
          }
        }


        this.circosControls.updateLegend(this.legendBooleans);


        // Setting the name
        if (data.fasta.data.length > 1 && data.fasta.name) {
          this.TEXT01[1].text = data.fasta.name.split('.')[0];
        } else {
          this.TEXT01[1].text = 'Chromosome ' + data.fasta.data[0][0];
        }
        this.TEXT01[1].x = -this.TEXT01[1].text.length * 3.8;
        this.TEXT01[1].textSize = 20 - modules.length;
        //  modules.push(this.TEXT01);


        this.BioCircos01 = new BioCircos(modules, data.fasta.data, {  // Initialize BioCircos.js with 'BioCircosGenome' and Main configuration
          // Main configuration

          target: 'biocircos',                       // Main configuration 'target'
          svgWidth: this.biocircos.nativeElement.clientWidth, // Main configuration 'svgWidth'
          svgHeight: (this.biocircos.nativeElement.clientHeight - 10),                            // Main configuration 'svgHeight'
          chrPad: 0.04,
          zoom: true,                           // Main configuration 'this.circosControls.setChromosomeList(this.chromosomes);chrPad'
          innerRadius: this.minRadiusTrack1,  // Main configuration 'innerRadius'  //if I change this, all tracks's thickness changes!
          outerRadius: this.maxRadiusTrack1,
          genomeFillColor: data.fillColor,
          LINKMouseEvent: true,
          LINKMouseOverDisplay: true,
          LINKMouseOverTooltipsHtml01: '',
          LINKMouseOverTooltipsHtml02: '',
          LINKMouseOverTooltipsPosition: 'absolute',
          LINKMouseOverTooltipsBackgroundColor: 'white',
          LINKMouseOverTooltipsBorderStyle: 'solid',
          LINKMouseOverTooltipsBorderWidth: 0,
          LINKMouseOverTooltipsPadding: '3px',
          LINKMouseOverTooltipsBorderRadius: '3px',
          LINKMouseOverTooltipsOpacity: 0.8,
          LINKMouseOutDisplay: true,
          LINKMouseOutStrokeColor: 'none',
          LINKMouseOutStrokeWidth: 1,

          // SNP tooltips
          SNPMouseOverDisplay: true,
          SNPMouseOverColor: 'red',
          SNPMouseOverCircleSize: 5,
          SNPMouseOverCircleOpacity: 1.0,
          SNPMouseOverCircleStrokeColor: '#F26223',
          SNPMouseOverCircleStrokeWidth: 3,
          SNPMouseOverTooltipsHtml01: 'chr : ',
          SNPMouseOverTooltipsHtml02: '<br>position : ',
          SNPMouseOverTooltipsHtml03: '<br>quality : ',
          SNPMouseOverTooltipsHtml04: '<br>rsid : ',
          SNPMouseOverTooltipsHtml05: '<br>AF : ',
          SNPMouseOverTooltipsBorderWidth: 1,
          SNPMouseOutDisplay: true,
          SNPMouseOutAnimationTime: 700,
          SNPMouseOutColor: 'none',
          SNPMouseOutCircleSize: 'none',
          SNPMouseOutCircleOpacity: 1.0,
          SNPMouseOutCircleStrokeWidth: 0,
          ARCMouseOverTooltipsHtml05: annotationOrdiff,
          // Histogramm toolt

          ticks: {
            'display': true,
            'len': 5,
            'rest': rest,
            'color': '#000',
            'textSize': 10,
            'textColor': '#000',
            'scale': this.tickLength,
            'zoomStart': roundZoomStart,
            'displayText': displayTickText
          }
        });
        this.BioCircos01.draw_genome(this.BioCircos01.genomeLength); // BioCircos.js callback
        this.circosControls.zoomStart = 0;
        this.circosControls.chromosomeZoomed = '';
      }
      this.loadingService.isCharging = false;
    }
  }

  convertLinksToARC(data, chromosomes) {
    let arcData1 = [];
    let arcData2 = [];
    let dataBinner = new DataBinner;
    let adjustedEnds = [];
    let genomeLength = dataBinner.calculateDisplayedGenomeLength(chromosomes.data);
    for (let i = 0; i < data.length; i++) {
      if (parseInt(data[i].g1end) > parseInt(data[i].g1start)) {
        adjustedEnds = dataBinner.adjustFragmentEnds(genomeLength, chromosomes.data, data[i].g1chr, data[i].g1start, data[i].g1end);
        dataBinner.mergeBins(arcData1, data[i].g1chr, adjustedEnds[0], adjustedEnds[1], data[i].color);
        //data[i].g1start=adjustedEnds[0];
        //data[i].g1end==adjustedEnds[1];
      } else {
        adjustedEnds = dataBinner.adjustFragmentEnds(genomeLength, chromosomes.data, data[i].g1chr, data[i].g1end, data[i].g1start);
        dataBinner.mergeBins(arcData1, data[i].g1chr, adjustedEnds[0], adjustedEnds[1], data[i].color);
        //data[i].g1start=adjustedEnds[0];
        //data[i].g1end==adjustedEnds[1];
      }
      if (parseInt(data[i].g2end) >parseInt(data[i].g2start)) {
        adjustedEnds = dataBinner.adjustFragmentEnds(genomeLength, chromosomes.data, data[i].g2chr, data[i].g2start, data[i].g2end);
        dataBinner.mergeBins(arcData2, data[i].g2chr, adjustedEnds[0], adjustedEnds[1], data[i].color);
        //data[i].g2start=adjustedEnds[0];
        //data[i].g2end==adjustedEnds[1];
      } else {
        adjustedEnds = dataBinner.adjustFragmentEnds(genomeLength, chromosomes.data, data[i].g2chr, data[i].g2end, data[i].g2start);
        dataBinner.mergeBins(arcData2, data[i].g2chr, adjustedEnds[0], adjustedEnds[1], data[i].color);
        //data[i].g2start=adjustedEnds[0];
        //data[i].g2end==adjustedEnds[1];
      }
      //arcData1.push({chr:data[i].g1chr, start:data[i].g1start, end:data[i].g1end, color:data[i].color});
      //arcData2.push({chr:data[i].g2chr, start:data[i].g2start, end:data[i].g2end, color:data[i].color});
    }
    return [arcData1, arcData2]
  }

  displayChromosomeGroups(groups: CircosGroup[]) {
    this.prepareGroupsForDisplay(groups);
  }

    prepareGroupsForDisplay(groups: CircosGroup[]): any {
    let fastas = [];
    const tracksMerge = {};
    const singleGroupTracks = [];
    console.log(groups)
    const that = this;

    const fillColor = [];

    const chromosomesLength = {};

    //const colorPalette = ['#44B3C2', '#F1A94E', '#E45641', '#5D4C46', '#7B8D8E', '#F2EDD8'];
    const colorPalette = environment.colorPalette;

    const fastaIDsGroupNames = [];

    //required to avoid adding links track twice
    const processedLinks = new Set();
      
    for (let i = 0; i < groups.length; i++) {
      let color;
      //groups[i].group.items[0] = JSON.parse(JSON.stringify(groups[i].group.items[0]));
      if (i < 6) {
        color = colorPalette[i];
      } else {
        color = 'rgb(' + Math.round(Math.random() * 255) + ',' +
          Math.round(Math.random() * 255) + ',' + Math.round(Math.random() * 255) + ')';
      }

      //rename chromosomes in Fasta file to GroupName_ChromsomeName
      for (let k = 0; k < groups[i].items.length; k++) {
        if (groups[i].items[k].isFasta) {
          fastaIDsGroupNames.push([groups[i].items[k].fileID, groups[i].name]);
          var node: FileNode = groups[i].items[k];
          for (let j = 0; j < node.data.length; j++) {
            chromosomesLength[node.data[j][0]] = node.data[j][1]; //creates dictionary of ChromosomeName ChromosomeLenght pairs
            if (node.data[j][0].indexOf('_') === -1) {
              node.data[j][0] = groups[i].name.concat('_').concat(node.data[j][0]);
            }
            groups[i].items[k].color=color;
            fillColor.push(color);
          }
          if (i !== 0 && !groups[i].isReversed) {
            fastas = fastas.concat(node.data.reverse());
          } else {
            fastas = fastas.concat(node.data);
          }
        }
      }

      let tracks: Array<FileNode> = [];
      for (let nonFasta of groups[i].items) {
        if (!nonFasta.isFasta) { tracks.push(nonFasta); }
      }

      for (let j = 0; j < tracks.length; j++) {
        let track: FileNode = tracks[j];

        let doMerge: boolean = true;
        if (!track.isLink) {
          this._InsertUnderscoreInTrackChromosomes(track, chromosomesLength, groups[i]);
        } else if (groups.length > 1 && !processedLinks.has(track.OldFasta.concat(track.NewFasta))) { //processed doesnt work
          if (this._InsertUnderscoreInLinksChromosomes(track, chromosomesLength, groups[i], fastaIDsGroupNames)) {
            processedLinks.add(track.OldFasta.concat(track.NewFasta));
          } else {
            doMerge = false;
          }
        }

        if (doMerge && groups.length > 1) {
          //doMerge avoids additing the Links track in case there is only one group, may need to change in the future
          if (!tracksMerge[track.format]) {
            tracksMerge[track.format] = [];
          }
          tracksMerge[track.format] = tracksMerge[track.format].concat((track.isLink) ? track.getLinkData(undefined).data : track.data);
          tracks[j] = track
        } else if (groups.length === 1) {
          singleGroupTracks.push({ format: track.format, data: track.data, file: track.fileID })
        }
      }

      //mark group data as reversed to avoid reversing already reversed
      groups[i].isReversed=groups[i].reverse;

    }

    const obj: any = { fasta: { data: fastas }, tracks: [] };
    if (groups.length === 1) {
      //the if clause is due to original code not permitting multiple same format tracks in case of multiple groups
      //because now groups are used automatically, this is a quick way of overcoming original design limitation
      for (let m = 0; m < singleGroupTracks.length; m++) {
        obj.tracks.push({ format: singleGroupTracks[m].format, data: singleGroupTracks[m].data, file: singleGroupTracks[m].file });
      }
    } else {
      for (const format in tracksMerge) {
        if (tracksMerge.hasOwnProperty(format)) {
          obj.tracks.push({ format: format, data: tracksMerge[format] });
        }
      }
    }

    obj.fillColor = fillColor;

    that.submitDisplayCircos(obj, 'comparison');
  }

  _InsertUnderscoreInTrackChromosomes(track: FileNode, chromosomesLength: {}, group: CircosGroup) {
    for (let k = 0; k < track.data.length; k++) {

      if (track.data[k].chr.indexOf('_') === -1) {
        if (group.reverse && !group.isReversed) {
          if (track.data[k].pos != undefined) {
            track.data[k].pos = chromosomesLength[track.data[k].chr] - track.data[k].pos;
          } else {
            track.data[k].start = chromosomesLength[track.data[k].chr] - track.data[k].start;
            track.data[k].end = chromosomesLength[track.data[k].chr] - track.data[k].end;
          }
        }
        track.data[k].chr = group.name + '_' + track.data[k].chr;
      }
    }
  }

  _InsertUnderscoreInLinksChromosomes(track: FileNode, chromosomesLength: {}, group: CircosGroup, fastaIDsGroupNames: any[]): boolean {
    let oldFastaGroupName: string = "";
    let newFastaGroupName: string = "";

    for (let i = 0; i < fastaIDsGroupNames.length; i++) {
      if (fastaIDsGroupNames[i][0] === track.NewFasta) {
        newFastaGroupName = fastaIDsGroupNames[i][1];
      } else if (fastaIDsGroupNames[i][0] === track.OldFasta) {
        oldFastaGroupName = fastaIDsGroupNames[i][1];
      }
    }

    //this resolves the problem that when first group is processed, the name of the second group is not known. 
    //ideally, on would process links after fasta chromosomes have been renamed
    if (newFastaGroupName === "" || oldFastaGroupName == "") { return false; }

    let linkData = track.getLinkData(undefined).data;
    let isLinkDataReversed = track.getLinkData(undefined).isDataReversed;
    let useg1= (group.name===oldFastaGroupName ? true : false)
    for (let k = 0; k < linkData.length; k++) {
      //reserses the order of values in the data. Hard to change given the structure of original code
      if (group.reverse && !isLinkDataReversed) {
        if (useg1) {
          linkData[k].g1start = chromosomesLength[linkData[k]._g1chr] - linkData[k].g1start;
          linkData[k].g1end = chromosomesLength[linkData[k]._g1chr] - linkData[k].g1end;
        } else { 
          linkData[k].g2start = chromosomesLength[linkData[k]._g2chr] - linkData[k].g2start;
          linkData[k].g2end = chromosomesLength[linkData[k]._g2chr] - linkData[k].g2end;
        }
      }
      linkData[k].g1chr=oldFastaGroupName+"_"+linkData[k]._g1chr
      linkData[k].g2chr=newFastaGroupName+"_"+linkData[k]._g2chr
      linkData[k].group1Name = oldFastaGroupName;
      linkData[k].group2Name = newFastaGroupName;
    }
    if (group.reverse && !isLinkDataReversed) {
      track.getLinkData(undefined).isDataReversed=true;
    }
    return true;
  }

  addGroup(name) {
    this.circosControls.addGroup(name);
  }

  defineTicks(length) {
    let lengthTick = 10000000;
    while ((length / lengthTick) < 70 && (length / lengthTick)) {
      lengthTick = lengthTick / 10;
    }
    if ((length / lengthTick) > 100) {
      lengthTick = 10 * lengthTick;
    }
    this.tickLength = lengthTick;
  }
  catchPickListEmittedBiocircos(e) {
    this.circosControls.catchPickListEmitted(e);
  }

  deleteGroup(name) {
    this.circosControls.deleteGroup(name);
  }
  editGroup(name) {
    this.circosControls.editGroup(name);
  }

  changeOnlyHomoSNP(checked) {
    this.showHomoSNP = checked;
    if (this.dataDisplayed) {
      this.submitDisplayCircos(this.dataDisplayed, this.mode);
    }
  }

  rgb(r, g, b) {
    return ['rgb(', r, ',', g, ',', b, ')'].join('');
  }

  colorGradient(scale, startColor, endColor) {
    const min = Math.min;
    const max = Math.max;
    const round = Math.round;

    const r = startColor[0] + scale * (endColor[0] - startColor[0]);
    const b = startColor[2] + scale * (endColor[2] - startColor[2]);
    const g = startColor[1] + scale * (endColor[1] - startColor[1]);
    const t = [round(min(255, max(0, r))), round(min(255, max(0, g))), round(min(255, max(0, b)))];
    return t;
  }


  onChangeDisplayMessage(event) {
    this.DisplayMessages = event;
  }

  updateGroup1(data) {
    this.filesNames = {};
    for (const track of data) {
      this.filesNames[track.id] = track.name;
    }

    this.circosControls.updateGroup1(data);
  }


  reorderTracks(event) {
    const order = event.order;
    const orderedTracks = [];
    const tracks = this.dataDisplayed.tracks;

    for (let i = 0; i < order.length; i++) {
      for (let j = 0; j < tracks.length; j++) {

        if (this.mode === 'single') {
          if (order[i].id === tracks[j].file) {
            orderedTracks.push(tracks[j]);
          }
        } else {
          if (order[i].format === tracks[j].format) {
            orderedTracks.push(tracks[j]);
          }
        }
      }
    }
    this.dataDisplayed.tracks = orderedTracks;
    this.submitDisplayCircos(this.dataDisplayed, event.mode);
  }

  catchHighlightGenes(event) {
    this.highlightedRegionAnnotation = event;
    this.submitDisplayCircos(this.dataDisplayed, this.mode);
  }

  showInstructionMessage(message) {
    this.msg = message;
  }

  openCustomisationPanel() {
    this.openCustomisation.emit();
  }

  displayFileLinks(data) {
    this.linksDisplayed = data.links;
    this.linksBoolean = true;

    if (this.dataDisplayed) {
      this.submitDisplayCircos(this.dataDisplayed, this.mode);
    } else {
      this.updateGroup1(data.fasta);
    }
  }

  hideLinks() {
    this.linksDisplayed = null;
    if (this.dataDisplayed) {
      this.submitDisplayCircos(this.dataDisplayed, this.mode);
    }
  }

  filterLinks(links) {
    const linksFiltered = [];
    for (const link of links) {
      if (this.dataDisplayed.fasta.data.find(el => { return el[0] === link.g1chr; }) &&
        this.dataDisplayed.fasta.data.find(el => { return el[0] === link.g2chr; })) {
        linksFiltered.push(link);
      } else {
        console.log(link)
      }
    }
    return linksFiltered;
  }

  redraw() {
    if (this.dataDisplayed) {
      this.submitDisplayCircos(this.dataDisplayed, this.mode);
    }
  }
}
